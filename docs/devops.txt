## Continuous Integration
[Build Status](https://jenkins.openfda.deleidos.com/buildStatus/icon?job=prototype-20150626_master)

Jenkins is an awesome piece of software that we have utilized for the continuous integration (CI) environment.  Jenkins jobs are configured to both build and test the software frequently, and also orchestrate the deployment of the Docker containers supporting the prototype to the provisioned EC2 instance. Status of the compilation/testing/packaging of the software can be viewed at the top of this section via the "Build Status" button.

Typically a Jenkins master/slave CI environment is used to accommodate an evolving software code base's compilation, testing, packaging and deployment requirements, but for the purposes of simplicity and the size of the prototype, a single instance configuration of Jenkins was provisioned.

## Continuous Monitoring
Since the prototype is deployed to a Docker execution environment the traditional OS metrics tools (Cloudwatch, Ganglia, Graphite, Nagios, etc..) could be used however; it was chosen to use the similarly awesome Cadvisor monitoring tool to provide both traditional OS and container metrics.  The Cadvisor interface is 
view-able here: http://openfda.deleidos.com:8080
Application health monitoring is also something that is traditionally configured to provide near real time information pertaining to the health of the various tiers of the application.  For the purposes of the prototype, a simple set of monitoring check(s) have been added with a very simple notification path in Jenkins.

## Configuration Management 
Ansible was used to orchestrate the installation and configuration of a Centos 7 OS (currently using the official Centos 7 EC2 Amazon Machine Image (AMI) from the AWS Marketplace) used for hosting the prototype.  Although AWS was used to host the Docker containers in the prototype's solution, any Centos 7 OS (bare metal on prem or in the cloud, or cloud provided VMs) will suffice.  The decision to use the power of the Linux container technology, facilitated by Docker, and the decoupling of the deployment of the containers allows for the solution to run either on-prem, or in other cloud providers.  Also, by using an Ansible playbook to provision the Centos 7 OS and not a container orchestration tool like the AWS Container Service or Kubernetes, allows for both the documentation of the OS packages required to run the prototype as well as the ability to provide a heterogeneous execution environment for the application (1 on prem, 1 in AWS, 1 in GCE; all load balanced through a proxy).  
It should also be stated that the Ansible playbook is run in Jenkins for continuous deployment however; the Ansible playbook can be run outside of the Jenkins environment as was done for the development and testing of the deployment approach in any Centos 7 OS (cloud or on-prem aka laptop) as the processing requirements of the machine executing the playbook, known as the control machine, are minimal.

## Continuous Deployment
[![Deployment Status](https://jenkins.openfda.deleidos.com/job/Deploy_Prototype/badge/icon)](https://jenkins.openfda.deleidos.com/job/Deploy_Prototype/)  
A Jenkins job allows for the automated deployment of the prototype to one or more Centos 7 instances.   A Vagrantfile is provided in the deployment project which will allow you 
to configure a simple control machine outside of the Jenkins environment to use for development/testing.  The status of the deploy can be viewed at the top of this section via the "Deployment Status" button.  By using a Jenkins job to execute the Ansible playbook used to deploy the prototype to one or more Centos 7 instances, any member of the team from development, testing to program management, can deploy a built and tested version of the software.  This removes the "fear" and/or apprehension traditionally known to exist on programs that have a separate team for development, testing, operations, etc.. which not only impede progress but also makes it that only a small portion of the team truly knows how the software is placed into operations which is detrimental to a project's longevity.  The added benefit to having a "push button deployment" capability is that in source control, there is both the code and deployment orchestration which can both evolve in lock step, and avoids the usually situation where the software imposed a dependency on the OS's packages or configuration, but that fact is only realized when the software is deployed operationally. 
